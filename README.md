![hypermodularity](https://logo.hypermodularity.com/2/cover.png)

![hypermodularity](hyper-modularity-cover1.png)

+ Modular architecture and hypermodularity 
+ Benefits of hypermodularity
+ Modular architecture and hypermodularity in Software Devlopment
+ Modularity and hypermodularity in Hardware development
+ Modularity and hypermodularity in the daily routine of a person working with people
+ Examples of usage between modularity and hypermodularity
+ The Benefits of using hypermodular approach
+ How to learn the Modular thinking approach?
+ How to learn the hypermodular thinking approach?
+ How to live in hyper modular world, how to manage the all modular elements?


+ What is Modular Design
+ Modular Design in Different Forms
+ Types of Modular Design
+ Modular Design in Advertising


## Modular architecture and hypermodularity 

modular architecture refers to the design of a system that is composed of independent units that can be combined to create a larger and more complex system. 
These independent units are called modules and can be easily replaced or modified without affecting the entire system. 

The benefits of modular architecture include:

### Flexibility: 
Modular architecture allows for easy modification and customization of a system. Adding new features, upgrading components, and fixing bugs can be done without disrupting the entire system.

### Scalability: 
Modular architecture supports scalability. 
It allows for the addition of new modules to the system, making it capable of handling increased workload.

### Reusability: 
Modules can be used in different systems or applications, saving time and resources in the development process.

### Maintenance: 
Modular architecture simplifies maintenance. 
The system can be easily maintained by replacing or updating the affected module without affecting the entire system.

Hypermodularity, on the other hand, takes modular architecture to the next level. It goes beyond the traditional modular approach and involves breaking down a system into smaller, more specialized modules. These modules are designed to work together seamlessly, creating a highly flexible and adaptable system.


## Benefits of hypermodularity

The benefits of hypermodularity include:

### Agility
Hypermodularity allows for rapid development and deployment of new features and services. Developers can work on individual modules without affecting the entire system, allowing for faster iteration and delivery.

### Resilience
Hypermodular systems are more resilient to failures. If one module fails, it can be easily replaced with a backup or a new module, without affecting the rest of the system.

### Customization
Hypermodularity allows for greater customization of the system. Modules can be added, removed, or replaced to meet specific requirements or business needs.

### Collaboration
Hypermodularity encourages collaboration among developers. Different teams can work on different modules, making it easier to manage the development process.

In summary, modular architecture and hypermodularity are important concepts for DevOps, hardware, and software developers. They offer significant benefits in terms of flexibility, scalability, reusability, maintenance, agility, resilience, customization, and collaboration. By adopting these approaches, developers can create robust, adaptable, and efficient systems that meet the needs of their customers and businesses.


## Examples of modularity and hypermodularity in Software Development

### Modularity:

+ A content management system (CMS) that uses modular architecture to allow users to easily add or remove modules for different features such as e-commerce, social media integration, and search engine optimization (SEO).

+ A web application that uses modular architecture to allow users to easily add or remove modules for different features such as user authentication, payment processing, and social media integration.

+ A modular video game engine that allows developers to easily add or remove components such as graphics rendering, physics simulation, and audio processing, without having to rebuild the entire engine.

+ A modular operating system that uses modular architecture to allow users to easily add or remove components such as device drivers, file systems, and network protocols, without having to reinstall the entire operating system.


### Hypermodularity:

+ A microservices-based architecture that breaks down a software application into small, independent services that can be developed and deployed separately, communicating with each other through APIs.

+ A modular data center that uses hypermodularity to break down the infrastructure into smaller, specialized components such as power distribution, cooling, networking, and storage, allowing for greater flexibility and scalability.

+ A smart home system that uses hypermodularity to allow users to easily add or remove devices such as smart lights, thermostats, and security cameras, and integrate them with other devices through a central hub.

+ A microservices-based architecture that breaks down a software application into small, independent services that can be developed and deployed separately, communicating with each other through APIs.

+ A containerized application that uses hypermodularity to break down the application into smaller, isolated components that can be easily deployed and scaled, without having to deploy the entire application.

+ A modular artificial intelligence platform that uses hypermodularity to allow developers to easily add or remove components such as natural language processing, computer vision, and speech recognition, as well as integrate with other AI platforms through APIs.




## Modularity and hypermodularity in hardware development

### Modularity:

+ A computer motherboard that uses modular architecture to allow users to easily add or remove components such as RAM, hard drives, and graphics cards, without having to replace the entire motherboard.

+ A modular drone that allows users to easily switch out components such as the camera, battery, or motors, without having to replace the entire drone.

+ A modular 3D printer that uses modular architecture to allow users to easily add or remove components such as the hot end, print bed, and extruder, without having to replace the entire printer.

+ A modular smartphone that allows users to easily switch out components such as the camera, battery, or processor, without having to replace the entire device.

+ A car built with modular architecture that allows for easy replacement of parts such as the engine, transmission, or suspension, without having to replace the entire vehicle.



### Hypermodularity:

+ A microserver that uses hypermodularity to break down the server into smaller, specialized components such as power supplies, CPUs, and memory, allowing for greater flexibility and scalability.

+ A modular server rack that uses hypermodularity to allow users to easily add or remove server modules, power modules, and networking modules, as well as integrate with other racks through a central management system.

+ A modular smartphone that uses hypermodularity to allow users to easily swap out individual components such as the camera, battery, or processor, as well as customize the phone's appearance and functionality through interchangeable modules.




## Modularity and hypermodularity in the daily routine of a person working with people

### Modularity:

+ A personal trainer who uses modular programming to create tailored workout plans for each client, based on their individual fitness goals and abilities.

+ A teacher who uses modular lesson plans to create customized learning experiences for each student, based on their individual learning style and level of understanding.

+ A therapist who uses modular therapy techniques to create personalized treatment plans for each client, based on their individual needs and goals.

### Hypermodularity:

+ A life coach who uses hypermodularity to break down the coaching process into smaller, specialized components such as goal setting, time management, and personal development, allowing for greater flexibility and customization.

+ A social worker who uses hypermodularity to break down the case management process into smaller, specialized components such as housing, education, and healthcare, allowing for greater collaboration and coordination with other service providers.

+ A mentor who uses hypermodularity to break down the mentoring process into smaller, specialized components such as career development, skill building, and personal growth, allowing for greater customization and scalability.



## Modularity and hypermodularity in preparing a presentation

### Modularity:

+ A presenter who uses modular slide templates to create a consistent visual style throughout the presentation, including headers, bullet points, and images.

+ A presenter who uses modular content modules to create a presentation with customized information for each audience, including data, graphics, and case studies.

+ A presenter who uses modular presentation software to create a presentation that can be easily customized and reused for multiple presentations, including themes, layouts, and transitions.

### Hypermodularity:

+ A presenter who uses hypermodularity to break down the presentation into smaller, specialized components such as introduction, main points, and conclusion, allowing for greater flexibility in adjusting the order or adding/removing components.

+ A presenter who uses hypermodularity to break down the presentation into smaller, specialized content modules such as videos, animations, and interactive elements, allowing for greater customization and engagement.

+ A presenter who uses hypermodularity to break down the presentation into smaller, specialized versions for different audiences, allowing for greater customization of the content and delivery style based on the audience's needs and preferences.



## Examples of usage between modularity and hypermodularity

### In software development

In software development, modularity is often used for creating reusable components that can be easily integrated into different applications. 
Hypermodularity, on the other hand, is often used for breaking down complex applications into smaller, specialized microservices that can be developed and deployed independently.

### Product design

In product design, modularity is often used for creating products with interchangeable parts that can be easily replaced or upgraded. 
Hypermodularity, on the other hand, is often used for creating products with highly customizable features and options.

### project management

In project management, modularity is often used for breaking down a project into smaller, manageable tasks that can be assigned to different team members. 
Hypermodularity, on the other hand, is often used for creating highly agile and adaptable project workflows that can be easily customized and adjusted based on changing requirements.



## The Benefits of using hypermodular approach:

### Flexibility:
Hypermodularity allows for a highly flexible approach to creating and managing systems, products, or projects. It allows for easy customization and modification, making it easier to adapt to changing needs and requirements.

### Scalability:
Hypermodularity allows for easy scalability of systems or products. It allows for the addition or removal of modules or components as needed, without affecting the entire system.

### Resilience:
Hypermodularity allows for highly resilient systems that can withstand failures or disruptions. It allows for easy replacement or repair of individual modules or components, without affecting the entire system.

### Efficiency:
Hypermodularity allows for more efficient development, deployment, and maintenance of systems or products. It allows for easy integration of different modules or components, reducing development time and costs.

### Collaboration:
Hypermodularity allows for greater collaboration among team members working on different modules or components. It allows for easy integration of different components, making it easier to work together on complex projects.

### Customization:
Hypermodularity allows for easy customization of systems or products. It allows for the creation of highly personalized systems or products, tailored to the specific needs of individual users or customers.

Overall, hypermodularity approach offers many benefits for creating and managing complex systems, products, or projects. 
It allows for greater flexibility, scalability, resilience, efficiency, collaboration, and customization, making it an ideal approach for many different applications.



## How to learn the Modular thinking approach?

Modular thinking is a way of approaching problems by breaking them down into smaller, more manageable pieces. Here are some steps you can take to learn modular thinking:

### Start with small problems: 
Begin by breaking down small problems into smaller, more manageable pieces. This will help you develop your modular thinking skills and build confidence.

### Identify the components: 
Once you have identified the problem, start identifying the different components or modules that make up the problem. Try to understand how these components work together to create the problem.

### Define the interfaces: 
Next, define the interfaces between the different components. This will help you understand how the different modules interact with each other.

### Develop a modular design: 
Once you have identified the components and interfaces, start developing a modular design. This should include how the different modules will work together to solve the problem.

### Test and iterate: 
Test your modular design to see if it solves the problem. If it does not, iterate and refine your design until you find a solution that works.

### Practice, practice, practice: 
Keep practicing modular thinking by breaking down larger problems into smaller, more manageable pieces. This will help you build your skills and become more comfortable with the approach.

### Learn from others: 
Seek out resources, books, and mentors who can help you learn more about modular thinking. You can also learn from others by studying their designs and solutions.

By following these steps, you can develop your modular thinking skills and become better equipped to tackle complex problems in a more efficient and effective way.


### How to learn the hypermodular thinking approach?

Hypermodular thinking is an advanced approach to problem-solving that involves breaking down complex systems or problems into smaller, highly specialized components or microservices. Here are some steps you can take to learn hypermodular thinking approach:

### Understand modularity: 
Before you can understand hypermodularity, it's important to understand modularity. Learn about modular design principles, practices, and tools.

### Study hypermodular systems: 
Study and analyze existing hypermodular systems, such as microservices architecture or modular product design. This will help you understand how different modules can work together to create a more flexible and scalable system.

### Learn to break down problems: 
Develop your ability to break down complex problems into smaller, more specialized components. This requires a deep understanding of the problem and the ability to identify the different components of the problem.

### Focus on interfaces: 
In hypermodularity, interfaces between different components are critical. Learn how to design effective interfaces that allow modules to work together seamlessly.

### Develop a modular mindset: 
Hypermodular thinking requires a mindset that is focused on breaking down problems into smaller pieces. Practice this mindset by breaking down problems in your daily life, such as organizing your workday or planning a trip.

### Experiment with hypermodularity:
Start experimenting with hypermodular design in your own work. Start with small projects and build your way up. This will help you gain experience and build your skills.

### Learn from others: 
Seek out resources, books, and mentors who can help you learn more about hypermodular thinking. You can also learn from others by studying their designs and solutions.

By following these steps, you can develop your hypermodular thinking skills and become better equipped to tackle complex problems in a more flexible and scalable way. Remember to start small, focus on interfaces, and keep experimenting to build your skills.


## Summary
How to live in hyper modular world, how to manage the all modular elements?

Living in a hyper-modular world means that we are constantly surrounded by an increasing number of specialized modules that are interconnected to form complex systems. Here are some ways to manage the all modular elements in a hyper-modular world:

### Develop a modular mindset
Adopt a modular mindset that allows you to break down complex problems into smaller, more manageable pieces. 
This will help you understand and manage the interconnected modules of a system.

### Understand the interfaces 
In a hyper-modular world, it's important to understand how different modules interface with each other. 
Learn about the different types of interfaces, such as APIs or protocols, and how they work.

### Use modular tools
Use modular tools to manage the different modules of a system. 
This includes tools for version control, testing, and deployment.

### Practice modular design
Use modular design principles to create systems that are flexible and scalable. 
This means breaking down systems into smaller, specialized modules that can be easily replaced or updated.

### Collaborate with others
Collaboration is key in a hyper-modular world. 
Work with others to share knowledge and expertise in managing the different modules of a system.

### Continuously learn
A hyper-modular world is constantly evolving. 
Continuously learn about new technologies and techniques for managing modular systems.

By adopting a modular mindset, understanding the interfaces, using modular tools, practicing modular design, collaborating with others, and continuously learning, you can effectively manage the all modular elements in a hyper-modular world.


## How to build infrastructure using hyper-modular design principles

Building a modular infrastructure for a small company with marketing, sales, and development departments requires a deep understanding of the company's needs and a hyper-modular thinking approach. Here are some key steps to consider:

1. Identify the components: Start by identifying the components or modules that make up each department. For example, the marketing department might include modules such as branding, social media, and content creation.

2. Define the interfaces: Once you have identified the components, define the interfaces between them. This will help you understand how the different modules interact with each other.

3. Design the modules: Design each module to be highly specialized and flexible. This will allow them to be easily replaced or updated as the company's needs change.

4. Build the infrastructure: Build the infrastructure using hyper-modular design principles. This means breaking down the infrastructure into smaller, specialized components that can be easily replaced or updated.

5. Implement smart tools: Implement smart tools that allow for seamless communication and collaboration between the different modules. This includes tools for project management, communication, and file sharing.

6. Test and iterate: Test the infrastructure to ensure it is working effectively. Iterate and refine the design until you find a solution that works.

7. Continuously improve: Continuously improve the infrastructure by monitoring its performance and making adjustments as necessary.

By following these steps, you can build a hyper-modular infrastructure for a small company with marketing, sales, and development departments that is flexible, scalable, and efficient. Remember to focus on specialization, flexibility, and collaboration to create a system that can adapt to the company's changing needs.



### Building Departments

Building an infrastructure using hyper-modular design principles involves breaking down the system into smaller, specialized components that can be easily updated or replaced. Here are some examples of components that could be included in a hyper-modular infrastructure for a small company with marketing, sales, and development departments:

1. Marketing department modules:
- Branding: Create and maintain consistent brand identity across all channels.
- Social media: Manage social media accounts and create content for different platforms.
- Content creation: Develop and produce marketing materials such as blog posts, videos, and infographics.

2. Sales department modules:
- Lead generation: Develop strategies to generate new leads and prospects.
- Sales enablement: Provide sales reps with tools and resources to close deals.
- Customer relationship management (CRM): Manage the company's interactions with customers and prospects.

3. Development department modules:
- Software development: Develop and maintain software applications and platforms.
- Quality assurance: Test software applications and platforms to ensure they meet quality standards.
- DevOps: Manage the company's IT infrastructure and ensure smooth deployment and operation of software applications and platforms.

4. Common modules:
- Project management: Plan, track, and manage projects across all departments.
- Communication: Facilitate communication between different departments and team members.
- File sharing: Share files and documents securely between different departments and team members.

These are just some examples of modules that could be included in a hyper-modular infrastructure for a small company with marketing, sales, and development departments. The specific modules will depend on the company's needs and goals. The key is to identify specialized components that can be easily updated or replaced as the company's needs change.



## How to do it?


Building the components using hyper-modular design principles means breaking down the components into smaller, specialized components that can be easily replaced or updated,

Here is a to-do list with explanations on how to build components using hyper-modular design principles for a non-technical person:
 
By following these steps, you can design and convert processes to hyper-modular components that are flexible, scalable, and efficient. 

Remember to focus on specialization, flexibility, and collaboration to create a system that can adapt to the process's changing needs.


### Identify the process: Start by identifying the process that you want to convert into hyper-modular components. This could be any process, such as a manufacturing process, a customer service process, or a project management process.

### Break down the process: 
Break down the process into smaller components or modules. 
Each module should be highly specialized and focused on one specific task. 
For example, a customer service process could be broken down into smaller modules such as answering calls, responding to emails, and handling complaints.

### Define the interfaces: 
Define the interfaces between the different modules. 
This will help you understand how the different modules interact with each other. 
For example, the interface between the answering calls module and the responding to emails module could be the customer database.

### Design the modules: 
Design each module to be highly specialized and flexible. 
This will allow them to be easily replaced or updated as the process evolves. 
For example, the answering calls module could be designed to handle different types of calls, such as sales calls, support calls, and billing calls.

### Build the components: 
Build the components using hyper-modular design principles. 
This means breaking down the components into smaller, specialized components that can be easily replaced or updated. 
For example, the answering calls module could be broken down into smaller components such as call scripts, FAQs, and customer information forms.

### Test and iterate: 
Test the components to ensure they are working effectively. 
Iterate and refine the design until you find a solution that works. 
For example, test the call scripts to ensure they are effective in handling different types of calls.

### Integrate the components: 
Integrate the components back into the overall process. 
Ensure that the interfaces between the different modules are working effectively. 
For example, ensure that the customer information forms are being properly transferred to the responding to emails module.

### Continuously improve: 
Continuously improve the process by monitoring its performance and making adjustments as necessary. 
For example, monitor the average call time for the answering calls module and adjust the call scripts to improve efficiency.

By following these steps, a non-technical person can build components using hyper-modular design principles, which can lead to a more efficient and effective process.



## The architecture of highly modularized, easily reconfigurable, highly decoupled, self-contained and reusable components is referred to as a microservices architecture.

##  [Component-based software engineering - Wikipedia](https://en.wikipedia.org/wiki/Component-based_software_engineering)

> **Component-based software engineering** (**CBSE**), also called **component-based development** (**CBD**), is a branch of software engineering that emphasizes the [separation of concerns](https://en.wikipedia.org/wiki/Separation_of_concerns "Separation of concerns") with respect to the wide-ranging functionality available throughout a given [software system](https://en.wikipedia.org/wiki/Software_system "Software system"). It is a reuse-based approach to defining, implementing and composing loosely coupled independent components into systems. This practice aims to bring about an equally wide-ranging degree of benefits in both the short-term and the long-term for the software itself and for organizations that sponsor such software.
> 
> Software engineering practitioners regard components as part of the starting platform for [service-orientation](https://en.wikipedia.org/wiki/Service-orientation "Service-orientation"). Components play this role, for example, in [web services](https://en.wikipedia.org/wiki/Web_service "Web service"), and more recently, in [service-oriented architectures](https://en.wikipedia.org/wiki/Service-oriented_architecture "Service-oriented architecture") (SOA), whereby a component is converted by the web service into a _service_ and subsequently inherits further characteristics beyond that of an ordinary component.
> 
> Components can produce or consume events and can be used for [event-driven architectures](https://en.wikipedia.org/wiki/Event-driven_architecture "Event-driven architecture") (EDA).


### Component-Oriented Design - COD

Software design approach that focuses on designing highly modularized, easily reconfigurable, highly decoupled, self-contained and reusable components we call Component-Oriented Design (COD).
Component based development is growing in popularity. And it presents a viable alternative to choosing between a monolith and microservices. 

### Why Use Component Based Architecture?

In this book, we present the benefits of component based development and how teams can switch to a component based architecture in few steps.

#### benefits

Component based architecture stays up-to-date, without rebuilding it from the scratch. 

That makes component based architecture a better fit for large, complex system

The modular components can be combined, decoupled, reused

How to Design Component-Oriented Software?

how to move to component based development from your existing monolith?

+ do not refactor, build a new smaller modules
+ connect a component/package/service in a logical stream of process
+ adopt the new function/logic throughout the process
+ support both the old and the new models simultaneously through format data


### Steps to a Successful Migration

When it comes to breaking up your monolith into component based development:

+    Focus on software delivery approaches and upskilling team members.
+    Build out the minimum infrastructure needed to deliver independently deployable components (e.g., containerized microservices) that expose self-service APIs.
+    Start tracking technical issues for new and legacy, including:
+        Counting errors released to production.
+        Service availability.
+        Time to remediate.
+    Consider cloud deployment options (as appropriate).
+    Implement basic monitoring for new and legacy.
+    Implement automation wherever possible.
+    Migrate in atomic steps.
    



+ about modular programming principles

Modular programming is a software engineering approach that involves breaking down a program into functional, independent modules. Each module is designed to be highly decoupled and self-contained, which allows it to be reused and reconfigured with ease.


A web application can be broken down into several smaller modules, such as a user authentication module, a content module, a payments module, and so on. Each module is designed to be independent and reusable, so that the overall application can be easily reconfigured or extended as needed.


A game engine can be broken down into several smaller modules, such as a graphics engine, a physics engine, a sound engine, and so on. Each module is designed to be independent and reusable, so that the overall engine can be easily reconfigured or extended as needed.



### macromodules and hypermodules


+ what are macromodules?

Macromodules are collections of components or modules that have been grouped together in order to form a larger, more complex system. They are typically used to create a system that is more efficient and cost effective than if the components were bought and assembled separately. Examples of macromodules include CPUs, memory boards, and hard disks.

+ what are hypermodules?

Hypermodules are collections of modules that have been grouped together to form a larger system that is more complex than a single module. They are typically used when a system needs to be highly modularized and easily reconfigurable, such as in an Artificial Intelligence (AI) application. Examples of hypermodules include neural networks, fuzzy logic systems, and computer vision systems.



+ what are a differences between macromodules and hypermodules?

The main difference between macromodules and hypermodules is in the complexity of the system they are used to create. Macromodules typically consist of components that are already integrated and are designed to create a single, larger system, while hypermodules are designed to be reconfigurable and modularized, allowing for more complex systems to be created. Additionally, macromodules are usually designed to be as cost effective as possible, while hypermodules are typically designed for speed and accuracy.


### supermodules and hypermodules?

+ what are supermodules?

Supermodules are a type of software module that is designed to be highly reusable, self-contained, and scalable. They are typically composed of multiple smaller modules that are connected together in order to perform a specific function or set of functions. Supermodules are designed to be used in multiple applications and to be easily customized and integrated into existing software.


+ what are hypermodules?

Hypermodules are a type of software module that is designed to be highly extensible and configurable. Unlike supermodules, hypermodules are not necessarily self-contained, but rather require other modules in order to function properly. Hypermodules are typically used to extend and enhance existing software applications, allowing them to perform more complex tasks than they would be able to do on their own.


+ What are a differences between supermodules and hypermodules?

The main difference between supermodules and hypermodules is that supermodules are self-contained and typically used in multiple applications, while hypermodules require other modules in order to function properly and are typically used to extend and enhance existing software applications. Supermodules are also typically designed to be highly reusable, while hypermodules are designed to be highly extensible and configurable.


### macromodularity and hypermodularity

+ what mean macromodularity?

Macromodularity is a software design approach that focuses on designing large and complex systems by breaking them down into smaller components, or modules. It is a way of organizing software components into distinct parts that can be built, tested, and maintained separately, while still working together as part of the larger system. This approach can help software developers create more robust and maintainable systems.

+ what mean hypermodularity?

Hypermodularity is a software engineering and architecture approach that is focused on dynamically creating and managing flexible, modular software systems. It involves building software components as highly independent, loosely coupled modules, and then using a platform or framework to dynamically manage how those modules interact and work together. This approach allows for more flexibility and scalability than traditional monolithic software architectures.


+ What are a differences between macromodularity and hypermodularity?

The main difference between macromodularity and hypermodularity is in the level of granularity of the modules. Macromodularity is focused on breaking down large and complex systems into smaller components, while hypermodularity is focused on creating highly independent and loosely coupled modules. Additionally, macromodularity focuses on static module design, while hypermodularity is focused on dynamic module design and management.

### multimodularity and hypermodularity

+ multimodularity

Multimodularity is the ability of a system to be composed of multiple, distinct modules that can be combined and recombined to create different configurations. This allows for flexibility and scalability, as well as the ability to modify or add components without having to completely rebuild the system.


+ hypermodularity

Hypermodularity is a concept in which a system is composed of multiple, loosely coupled modules that can be connected and recombined in a variety of ways. This allows for a high degree of flexibility and scalability, as well as the ability to modify or add components without having to completely rebuild the system.

+ differents between multimodularity and hypermodularity

The main difference between multimodularity and hypermodularity is in the degree of coupling between the modules. Multimodularity is composed of distinct modules that are tightly coupled and cannot be easily recombined, while hypermodularity is composed of loosely coupled modules that can be connected and recombined in a variety of ways. Hypermodularity provides a higher degree of flexibility and scalability.


# [HyperModularity](https://www.hypermodularity.com/)

Hypermodularity is an attractive principle for software and hardware architecture.

Infrastructure of an organisation 

+ e.g by assembling the infrastructure of an organisation from a large amount of elements.
 
 
## What Does Modularity Mean?

In software engineering, modularity refers to the extent to which a software/Web application may be divided into smaller modules. Software modularity indicates that the number of application modules are capable of serving a specified business domain.

Modularity is successful because developers use prewritten code, which saves resources. Overall, modularity provides greater software development manageability.

Modern business issues grow on a continuous basis - in terms of size, complexity and demand. Enhanced software capability requirements force developers to enhance developed systems with new functionalities.

Software engineering modularity allows typical applications to be divided into modules, as well as integration with similar modules, which helps developers use prewritten code. Modules are divided based on functionality, and programmers are not involved with the functionalities of other modules. Thus, new functionalities may be easily programmed in separate modules.

+ [What is Modularity? - Definition from Techopedia](https://www.techopedia.com/definition/24772/modularity)

##  Modular programming 

Modular programming is a software design technique that emphasizes separating the functionality of a program into independent, interchangeable modules, such that each contains everything necessary to execute only one aspect of the desired functionality.

A module interface expresses the elements that are provided and required by the module. The elements defined in the interface are detectable by other modules. The implementation contains the working code that corresponds to the elements declared in the interface. Modular programming is closely related to structured programming and object-oriented programming, all having the same goal of facilitating construction of large software programs and systems by decomposition into smaller pieces, and all originating around the 1960s. While the historical usage of these terms has been inconsistent, "modular programming" now refers to the high-level decomposition of the code of an entire program into pieces: structured programming to the low-level code use of structured control flow, and object-oriented programming to the data use of objects, a kind of data structure.

In object-oriented programming, the use of interfaces as an architectural pattern to construct modules is known as interface-based programming.[citation needed] 

+ [Modular programming - Wikipedia](https://en.wikipedia.org/wiki/Modular_programming)


## Modular Design


Modular design allows for modifications to systems, recombination of existing capabilities and upgrade of system elements, to enable competition, innovation, rapidly responding to a changing environment, etc.(see also Systems Engineering (SE) Guidebook, Section 2.2.5 Modular Open Systems Approach). Designing for modularity is a key technical principle for implementing a modular open systems approach (MOSA) and is a complementary piece to the open system practices in contracting. The major tenet of a modular design strategy is to develop loosely coupled modules, where modules can be decoupled, separated or even re-arranged in a major system platform and major system components developed under the program, as well as major system components developed outside the program that will be integrated into the Major Defense Acquisition Program (MDAP). When designing for modularity, the system should be appropriately partitioned into discrete, scalable, self-contained functional elements by decomposing and decoupling the functions of a system. This functional partitioning results in elements that can now be composed into modules that can be reconfigured or even replaced.

Acquisition programs implementing a modular design provide flexible system designs, which allow for the replacement or recombination of subsystems and components. It is important for the program management to understand the expected benefit from modular design as part of implementing a MOSA strategy. This understanding provides guidance to the system realization, on which enabling elements (e.g., standards, contract clauses, engineering tools, etc.) to use. MOSA benefits are usually categorized into six individually useful areas, which often overlap: risk reduction; cost savings/cost avoidance; increased competition; enhanced interoperability; application of innovative elements; and ability to realize technology upgrade opportunities easily.

+ [Modular Design](https://www.dau.edu/tools/se-brainbook/Pages/Design%20Considerations/Modular-Design.aspx)


## About Hypermodularity

Hypermodularity is about objects not about actions, we combine processes with objects.

Hypermodularisation is a continouous process focused on atomisation of the system objects.


I'ts like a rain-worm, you cutted into the pieces and it still functions, but at a higher level


You get a smaller part with the same functionality.


With the smaller size of a module the following benefits comming up.

+ modules get more specialised
+ such a specialisation brings about higher quality
+ 

What if I get more functionality at the same size.

We atomize the objects to bring it to make them more specialised.

It's a sinn to atomize something's only if you can 

The all questions are about hyper modularity.

What we want to get is the increease quality.

## Process over code

What I can propose is to build the code based on DSL and prepare a documentation based on patterns.
I read a book about SCRUM (https://www.amazon.de/Scrum-Doing-Twice-Work-Half/dp/B00NTP70AQ) 
and must say that the scrum can't improve it, so what can help? maybe some methodology to improve the communication on processes,
where meet all people, so this is what I call #hypermodularity, what can to improve the process not just a code.



## For whom?


Some people are doing many things during whole life and some are just enjoy awhile.

Some colleage was very effective at work
I was surprised he had a family and 2 childrens.
Looks like to have family give the power and determination to reach the goals!

I see the same in my case,
There is documented coincides with the establishment and expansion of the family.
Wife and 2 childrens don't stopped my carrer, but helped increase the number of implemented projects.
 
It's very wondering experience for me.

When you are a parent, you don't have many hours at your disposal, rather they are torn quarters of an hour.
That's why I decided to write a book about it: Hypermodularisation in real projects, exactly what give me many benefits to finish a project in small steps, even you have the family ...



## Imagine it

Imagine your Company that is doing better service, automatic every day 
Based on Industry 4.0 and decentralized global network based on 5g and 6g, 
Automatized infratsructure, managed by artifactial intelligence
Be leader, grow without borders and continuously 
every day, hour and second.


## Continous hypermodularity

With Continous hypermodularity we are going to defined smaller and better processes, that can work togheter without stopping them on the stream!



### Synonyms 

+ Super Modularity
+ Extreme Modularity

### Tags:

+ Modular architecture
+ Architecture Flow


## Definition of Modularity in Software Architecture

Modularity is a way to extract each part of code, such functions as a generic part instead of group related code together.
Most languages have modularity structures, such as packages in Java, with hypermodularity we based ons separated functions.



## Why make a Modularization 

+ To provide a clear separation of concerns for the application's functionality
+ To easily implement app performance upgrades like code splitting and AoT compilation

In fact, modularization is now such an important part of building web apps that Angular requires you to architect your applications with it out of the box!

While AngularJS also had a module system, it was often ignored by developers as it often didn't provide enough advantages to make it completely necessary.



## Benefits of Modularization

+ the customized bricks are tested and ready to use
+ production cost are significantly decreased 
+ reliability of the system is increased due to fewer single points of failure. 


## Satisfy Customers and Decrease Costs

Modularization is a method that can be employed during the product development process to create innovative products that customers love, while keeping production costs low. 
Key to a modular, customizable product is to identify which are the functions and parts of the product that are noticed and important to the customers. 
The rest of the product should be kept standard for as many product lines as possible.
That way you can offer your customers choices and give them a feeling of having this unique product they were looking for, while saving big in the background.

https://brainmates.com.au/general/modularization-satisfy-customers-and-decrease-costs/


# The way

Some people are doing many things during whole life and some are just enjoy awhile.

How to focus on continuous development?

When you are a parent, you don't have many hours at your disposal, rather they are torn quarters of an hour.

That's why I decided to write a book about it: Hypermodularisation in real projects, exactly what give me many benefits to finish a project in small steps, even you have the family ...




# Modularity vs Hyper modularity

+ perfectionism in modularization 
+ simplify to the limit
+ give independence
+ that it should be still usefull 


## What is an application

An apllication is a program with an interface


## What is an Interface

An interface is a first layer to interact with an logic program.


## What is a Module

+ an application extension
+ works inside application


## What is a Library

it's a defined and good designed generic function/helper or many function focused on specific area 


## What is a Helper

Helper it's small generic part in context of program


## What is a Package

It's an independent library to be use in a program



# Hyper modularity process


+ Split the smallest possible reusable elements

## What is the different between Modularisation and hyper modularisation

modularization is focusing on *grouping* the generic parts 
while hyper modularization is focusing on *splitting* the specific parts



## What is a Hyper modularity 

+ it's not just about grouping as model,
+ it's not just about extract small independent generic parts 
+ its' about the best solution for specific usage


## Hyper modularity results

huge result wiht litlle energy involved.
+ that's the leverage mechanism 
Cost reduction, lifetime design, and radical hypermodularity, are some of our keys to maximizing platform scalability towards


<script src="https://unpkg.com/@lottiefiles/lottie-player@latest/dist/lottie-player.js"></script>
<lottie-player src="https://assets3.lottiefiles.com/private_files/lf30_csdufwaz.json"  background="transparent"  speed="1"  style="width: 300px; height: 300px;"  loop autoplay></lottie-player>



## Architecture of Systems, level of Modularisation

Module API can be invoked not only via HTTP API but via different infrastructure adapters
It's important to distinguish between different APIs (and contracts) on different levels.

Depending system the modules might be hidden.
It might be delegated to the messaging/event infrastructure altogether.

+ At class level - hide its state behind methods,
+ At the module level - hide its classes behind the module API,
+ At the system level - hide its modules behind the system API,
+ Encapsulating at different levels of architecture makes it possible to tackle complexity.



# Hypermodularity on monolith


## Packages, Dependencies, Classes

based on packages and namespaces the Classnames are overrided, but not each function/class method can be overrided.
So we should based on sperated functions to make it.

Going forward with such idea it's better to create each function separatly.

In another way, The Architects need to be aware of how products are packaged by developers and it has major architectural consequences. 
For example, if many packages are closely coupled together, it becomes more difficult to reuse one of them.


## Modular Reuse Before Classes

After "structured programming languages" era software developers started working with object-oriented languages,
today there are so many different separation schemes, so
it's easier to make one step forward to functional without some abstarctions such classes.

Modula and Ada had a module programming structure, just like today's packages or namespaces.

Object-oriented programming languages became popular when new ways of reusing code were introduced.


## Modularity in practice

A term used to describe code grouping is modularity.

hyper modularization is the process of extracting the code into the smallest possible parts, e.g. extracting functions from classes meeting the expectations of "Single Responisbility" and "Dependency Injection" 

From a simplicity standpoint, grouping a large number of classes together in a monolithic application can make sense. However, when the time comes for the architecture to be restructured, the coupling becomes an obstacle to breaking the monolith apart. For software artifacts, such as components, classes, and so on, developers also need qualified names to differentiate different software artifacts from each other to reduce conflict.


## The shared module

In the next chapter we're going to cover a critical type of module that you'll need to create in any reasonably sized application: the shared module.


# Hypermodularity on services layer


##  Modularized and decentralized architecture based on micro- and nano- services.

+ Nanoservices
+ Microservices
+ Devops
+ Architecture


## microservices -> nanoservices

What is the differend

On microservices we are working with packages and many classes to build some independent part osf system which can be independet service

+ DB

+ Auth

+ + roles


## layers

With more advanced servcies with independent latyer for auuthorisation, API, ...
We can just create one by one FaaS Functions as a Service using all of layers

We call it annoservices


The nanoservices based on existing infrastructure



# Packages modularity


## modularity in existing packages

how to make it step by step

how to extract from one packages all of functions?


## Articles

+ https://dev.to/workpebojot/architecting-modules-for-software-modularity-part-2-3bpc

+ https://programmersought.com/article/5310963279/

+ https://clintberry.com/2013/modular-angularjs-application-design/

+ https://link.springer.com/article/10.1007/s10202-008-0065-z


11 Principles Supported by Softreck's Extreme Manufacturing

The Test Driven Design aspect and Contract First Manufacturing are unique


## Contract-First Design

design the interface to other modules before designing the module


## Test Driven Development

design a series of tests that determines whether it will work, prior to doing design work
   

## Extreme Learning

in order to further a zero-waste development process, we focuses on training in practice, we produce lean instructionals intended for rapid learning.
This means that we optimize existing instructionals to facilitate the learning curve of advanced development techniques - especially with the interest of bringing people up to speed from zero. We like working with rapid-learning novices, as such people can become effective without the industrial inertia (old and prejudiced design ideas).


## Optimize for change

agility, adaptability of design is foremost to achieve desired result (complete, functional, minimal viable product)


## Object-Oriented, Modular Architecture

Modularity allows build a large system in parallel, as long as all the interfaces are well-defined for the modules. 
Modularity allows for a complete Product Ecology to emerge - for closed-loop manufacturing cycles. 
Modular architecture allows us to optimize 'borrowing' from other projects such that the development process is globally collaborative.
   
   
## Iterate the Design

Create the test that your design should pass.
Create the simplest design possible that enables the test to pass.
Improve the design to be simpler or more elegant.  Repeat this process ("Iterate on the design") until improving this component is no longer the highest value work you can do.
   
## Agile Hardware Design Patterns

wrapper (interface to the interface), common materials, tech recursion (invest in tools that make components and that make materials), 
Lifetime Design (so that hardware can be repaired easily)
  
  
## Continuous Integration Development

iterate continuously between product test, design, and manufacturing. This involves Design for Manufacturing, Design for Disassembly, Design for Fabricability, Design for Maintainability.
Product Service Systems allows testing as a scalable enterprise model for open source hardware.
Our current beta testing for build efficiency of this model is ongoing with our 
Extreme Manufacturing Workshops.
   
 
## Continuously Deployed Development

How to go to market fast? Flexible Fabrication concept. Digital fabrication assist. Open Design. Open Source R&D capacity, rapid prototyping, integrated R&D lab a la Edison.

## Scaling Patterns

Create teams for each module. Teams can work in parallel. Multiple teams can work on same module. Different teams can work on different aspects - design, build, documentation, prototyping, testing. Teams should have open communication channels, such as Work Log on our wiki or Dozuki structure, or video uploads, plus Forums, Stack Exchange, Design Sprints, and Leader Training Workshops. 


## Workshops Team and Customer

Scrum of Scrums, Product Owner and Scrum Maseter. Clear Customer Visible Value is generated and iterated. 
Chief Product Owner (CPO) sequences and refines the Portfolio Product Backlog continuously.
User stories are the requirements. Scrum Masters negotiate with other Scrum Masters for resources. 
All work completed satisfies the quality metric called the Definition of Done. Product owner maintains backlog and clarity. Scrum master maintains transparency of product delivery via documentation. Global remote effort can be maintained by heavy documentation typical of Open Source. 


## Documentation Flow

Heavy Documentation is Key to a Lean Process - which appears counterintuitive at first but is relevant to solving wicked problems.


## Partner Patterns

Easy sourcing from many partners. Wrapper is key to this flexibility - an interface of the interface design. 
Design collaboration with industry. 
University Collaborations for R&D. 
Wide portfolio of Freelancers to do design, build, and service along a Product Service System model.



# hyper modularity in another areas


    What is Modular Design
    Modular Design in Different Forms
    Types of Modular Design
    Modular Design in Advertising
    
 


## Network

 Networks with high modularity have dense connections between the nodes within modules but sparse connections between nodes in different modules. Modularity is often used in optimization methods for detecting community structure in networks. However, it has been shown that modularity suffers a resolution limit and, therefore, it is unable to detect small communities. Biological networks, including animal brains, exhibit a high degree of modularity. 
 


## Abstraction and AI

abstraction is depends context, so it can be good in some context, not ewerywhere, that's why I support personally Native Technologies, Microsoftsolutions are full of abstractions, but AI don't need it, so what is the future?
AI or Microsoft?



## Modularity is the king

That's why with modularity we can handle AI skills to build us better technology world, wit rapidly development and documented such describing world with words



### for abstraction friends

There is nothing wrong if abstraction is describing business logic for a human.
We need it till AI is not used to create hypermodular application by itself.
If AI is responsible for streaming application there si no more necessary to create abstraction.

What AI need?
native modular code written in native technologies.
AI is build the businnes logic over personalisation based on BIG DATA
It works such Black BOX with:
+ input
+ output
+ config


## Books

+ https://www.google.com/search?tbm=bks&q=modularity


Modularity: Understanding the Development and Evolution of Natural Complex Systems
+ https://books.google.de/books?id=xfW6mmAJWjwC


## Example projects

+ [www.webstream.dev](https://www.webstream.dev/#/)


---

## About Tom Sapletta

+ [Contact on linkedin](https://www.linkedin.com/in/tom-sapletta-com/)
+ [Tom Sapletta Blog - Embedded System Software & Hardware Developer](https://tom.sapletta.com/)
+ [Softreck Company - Leadership Through Software Development](https://softreck.com/)


## Sponsored by:

+ [Softreck - Leadership Through Software Development](https://softreck.com/)




---
+ [edit](https://github.com/hypermodularity/www/edit/main/README.md)

```
https://github.com/hypermodularity/www.git
```
